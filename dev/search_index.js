var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CodeDiffs","category":"page"},{"location":"#CodeDiffs","page":"Home","title":"CodeDiffs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compare different types of code and display it in the terminal. For cleaner results, syntax highlighting is separated from the difference calculation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supports:","category":"page"},{"location":"","page":"Home","title":"Home","text":"native CPU assembly (output of @code_native, highlighted by InteractiveUtils.print_native)\nLLVM IR (output of @code_llvm, highlighted by InteractiveUtils.print_llvm)\nTyped Julia IR (output of @code_typed, highlighted through the Base.show method of Core.CodeInfo)\nJulia AST (an Expr), highlighting is done with OhMyREPL.jl's Julia syntax highlighting in Markdown code blocks","category":"page"},{"location":"","page":"Home","title":"Home","text":"The @code_diff macro is the main entry point. If possible, the code type will be detected automatically, otherwise add e.g. type=:llvm for LLVM IR comparison:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f1(a) = a + 1\nf1 (generic function with 1 method)\n\njulia> @code_diff type=:llvm debuginfo=:none color=false f1(Int64(1)) f1(Int8(1))\ndefine i64 @f1(i64 signext %0) #0 {   ⟪╋⟫define i64 @f1(i8 signext %0) #0 {\ntop:                                   ┃ top:\n                                       ┣⟫  %1 = sext i8 %0 to i64\n  %1 = add i64 %0, 1                  ⟪╋⟫  %2 = add nsw i64 %1, 1\n  ret i64 %1                          ⟪╋⟫  ret i64 %2\n}                                      ┃ }\n\njulia> f2(a) = a - 1\nf2 (generic function with 1 method)\n\njulia> @code_diff type=:llvm debuginfo=:none color=false f1(1) f2(1)\ndefine i64 @f1(i64 signext %0) #0 {   ⟪╋⟫define i64 @f2(i64 signext %0) #0 {\ntop:                                   ┃ top:\n  %1 = add i64 %0, 1                  ⟪╋⟫  %1 = add i64 %0, -1\n  ret i64 %1                           ┃   ret i64 %1\n}                                      ┃ }","category":"page"},{"location":"","page":"Home","title":"Home","text":"Setting the environment variable \"CODE_DIFFS_LINE_NUMBERS\" to true will display line numbers on each side:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ENV[\"CODE_DIFFS_LINE_NUMBERS\"] = true\ntrue\n\njulia> @code_diff type=:llvm debuginfo=:none color=false f1(1) f2(1)\n1 define i64 @f1(i64 signext %0) #0 { ⟪╋⟫define i64 @f2(i64 signext %0) #0 { 1\n2 top:                                 ┃ top:                                2\n3   %1 = add i64 %0, 1                ⟪╋⟫  %1 = add i64 %0, -1               3\n4   ret i64 %1                         ┃   ret i64 %1                        4\n5 }                                    ┃ }                                   5","category":"page"},{"location":"#Comparison-entry-points","page":"Home","title":"Comparison entry points","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@code_diff\n@code_for\ncode_diff\ncode_for_diff\nCodeDiff","category":"page"},{"location":"#CodeDiffs.@code_diff","page":"Home","title":"CodeDiffs.@code_diff","text":"@code_diff [type=:native] [color=true] [cleanup=true] [option=value...] f₁(...) f₂(...)\n@code_diff [option=value...] :(expr₁) :(expr₂)\n\nCompare the methods called by the f₁(...) and f₂(...) or the expressions expr₁ and expr₂, then return a CodeDiff.\n\noptions are passed to get_code. Option names ending with _1 or _2 are passed to the call of get_code for f₁ and f₂ respectively. They can also be packed into extra_1 and extra_2.\n\nTo compare Expr in variables, use @code_diff :($a) :($b).\n\ncleanup == true will use cleanup_code to make the codes more prone to comparisons (e.g. by renaming variables with names which change every time).\n\n# Default comparison\n@code_diff type=:native f() g()\n\n# No debuginfo for `f()` and `g()`\n@code_diff type=:native debuginfo=:none f() g()\n\n# No debuginfo for `f()`\n@code_diff type=:native debuginfo_1=:none f() g()\n\n# No debuginfo for `g()`\n@code_diff type=:native debuginfo_2=:none f() g()\n\n# Options can be passed from variables with `extra_1` and `extra_2`\nopts = (; debuginfo=:none, world=Base.get_world_counter())\n@code_diff type=:native extra_1=opts extra_2=opts f() g()\n\n# `type` and `color` can also be made different in each side\n@code_diff type_1=:native type_2=:llvm f() f()\n\n\n\n\n\n","category":"macro"},{"location":"#CodeDiffs.@code_for","page":"Home","title":"CodeDiffs.@code_for","text":"@code_for [type=:native] [color=true] [io=stdout] [cleanup=true] [option=value...] f(...)\n@code_for [option=value...] :(expr)\n\nDisplay the code of f(...) to io for the given code type, or the expression expr (AST only).\n\noptions are passed to get_code. To display an Expr in a variable, use @code_for :($expr).\n\nio defaults to stdout. If io == String, then the code is not printed and is simply returned.\n\nIf the type option is the first option, \"type\" can be omitted: i.e. @code_for :llvm f() is valid.\n\ncleanup == true will use cleanup_code on the code.\n\n# Default comparison\n@code_for type=:native f()\n\n# Without debuginfo\n@code_for type=:llvm debuginfo=:none f()\n\n# Options sets can be passed from variables with the `extra` options\nopts = (; debuginfo=:none, world=Base.get_world_counter())\n@code_for type=:typed extra=opts f()\n\n# Same as above, but shorter since we can omit \"type\"\n@code_for :typed extra=opts f()\n\n\n\n\n\n","category":"macro"},{"location":"#CodeDiffs.code_diff","page":"Home","title":"CodeDiffs.code_diff","text":"code_diff(args₁::Tuple, args₂::Tuple; extra_1=(;), extra_2=(;), kwargs...)\n\nFunction equivalent to @code_diff(extra_1, extra_2, kwargs..., args₁, args₂). kwargs are common to both sides, while extra_1 and extra_2 are passed to code_for_diff only with args₁ and args₂ respectively.\n\njulia> diff_1 = @code_diff debuginfo_1=:none f() g();\n\njulia> diff_2 = code_diff((f, Tuple{}), (g, Tuple{}); extra_1=(; debuginfo=:none));\n\njulia> diff_1 == diff_2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.code_for_diff","page":"Home","title":"CodeDiffs.code_for_diff","text":"code_for_diff(f, types::Type{<:Tuple}; type=:native, color=true, cleanup=true, kwargs...)\ncode_for_diff(expr::Expr; type=:ast, color=true, kwargs...)\n\nFetches the code of f with get_code(Val(type), f, types; kwargs...), cleans it up with cleanup_code(Val(type), code) and highlights it using the appropriate code_highlighter(Val(type)). The result is two Strings: one without and the other with highlighting.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.CodeDiff","page":"Home","title":"CodeDiffs.CodeDiff","text":"CodeDiff(code₁, code₂)\nCodeDiff(code₁, code₂, highlighted₁, highlighted₂)\n\nA difference between code₁ and code₂.\n\ncode₁ and code₂ should have no highlighting. Only highlighted₁ and highlighted₂ should have syntax highlighting. When showing the differences, their formatting will be re-applied.\n\nFor cleaner differences, use replace_llvm_module_name on all codes.\n\nUse optimize_line_changes! to improve the difference.\n\nFancy REPL output is done with side_by_side_diff.\n\n\n\n\n\n","category":"type"},{"location":"#Code-fetching","page":"Home","title":"Code fetching","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"code_native\ncode_llvm\ncode_typed\ncode_ast\nget_code","category":"page"},{"location":"#CodeDiffs.code_native","page":"Home","title":"CodeDiffs.code_native","text":"code_native(f, types; world=nothing, kwargs...)\n\nThe native code of the method of f called with types (a Tuple type), as a string. world defaults to the current world age. kwargs are forwarded to InteractiveUtils.code_native.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.code_llvm","page":"Home","title":"CodeDiffs.code_llvm","text":"code_llvm(f, types; world=nothing, kwargs...)\n\nThe LLVM-IR code of the method of f called with types (a Tuple type), as a string. world defaults to the current world age. kwargs are forwarded to InteractiveUtils.code_native.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.code_typed","page":"Home","title":"CodeDiffs.code_typed","text":"code_typed(f, types; world=nothing, kwargs...)\n\nThe Julia-IR code (aka 'typed code') of the method of f called with types (a Tuple type), as a Core.CodeInfo. world defaults to the current world age. kwargs are forwarded to Base.code_typed.\n\nThe function call should only match a single method.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.code_ast","page":"Home","title":"CodeDiffs.code_ast","text":"code_ast(f, types; world=nothing, prettify=true, lines=false, alias=false)\n\nThe Julia AST of the method of f called with types (a Tuple type), as a Expr. Revise.jl is used to get those definitions, and it must be loaded before the definition of f's method to get the AST for.\n\nworld defaults to the current world age. Since Revise.jl does not keep track of all definitions in all world ages, it is very likely that the only retrievable definition is the most recent one.\n\nIf prettify == true, then MacroTools.prettify(code; lines, alias) is used to cleanup the AST. lines == true will keep the LineNumberNodes and alias == true will replace mangled names (or gensyms) by more readable names.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.get_code","page":"Home","title":"CodeDiffs.get_code","text":"get_code(::Val{code_type}, f, types; world=nothing, kwargs...)\n\nThe code object of code_type for f. Dispatch depends on code_type:\n\n:native: code_native\n:llvm: code_llvm\n:typed: code_typed\n:ast: code_ast\n\n\n\n\n\n","category":"function"},{"location":"#Highlighting","page":"Home","title":"Highlighting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"code_highlighter","category":"page"},{"location":"#CodeDiffs.code_highlighter","page":"Home","title":"CodeDiffs.code_highlighter","text":"code_highlighter(::Val{code_type}) where {code_type}\n\nReturn a function of signature (io::IO, code_obj) which prints code_obj to io with highlighting/decorations. By default print(io, code_obj) is used for AbstractStrings and Base.show(io, MIME\"text/plain\"(), code_obj) otherwise.\n\nThe highlighting function is called twice: once for color-less text and again with color.\n\n\n\n\n\n","category":"function"},{"location":"#Cleanup","page":"Home","title":"Cleanup","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"cleanup_code\nreplace_llvm_module_name\nfunction_unique_gen_name_regex\nglobal_var_unique_gen_name_regex","category":"page"},{"location":"#CodeDiffs.cleanup_code","page":"Home","title":"CodeDiffs.cleanup_code","text":"cleanup_code(::Val{code_type}, code)\n\nPerform minor changes to code to improve readability and the quality of the differences.\n\nCurrently only replace_llvm_module_name is applied to :native and :llvm code.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.replace_llvm_module_name","page":"Home","title":"CodeDiffs.replace_llvm_module_name","text":"replace_llvm_module_name(code::AbstractString)\n\nRemove in code the trailing numbers in the LLVM module names, e.g. \"julia_f_2007\" => \"f\". This allows to remove false differences when comparing raw code, since each call to code_native (or code_llvm) triggers a new compilation using an unique LLVM module name, therefore each consecutive call is different even though the actual code does not change.\n\nIn Julia 1.11+, global variables names are also replaced with global_var_unique_gen_name_regex.\n\njulia> f() = 1\nf (generic function with 1 method)\n\njulia> buf = IOBuffer();\n\njulia> code_native(buf, f, Tuple{})  # Equivalent to `@code_native f()`\n\njulia> code₁ = String(take!(buf));\n\njulia> code_native(buf, f, Tuple{})\n\njulia> code₂ = String(take!(buf));\n\njulia> code₁ == code₂  # Different LLVM module names...\nfalse\n\njulia> replace_llvm_module_name(code₁) == replace_llvm_module_name(code₂)  # ...but same code\ntrue\n\n\n\n\n\nreplace_llvm_module_name(code::AbstractString, function_name)\n\nReplace only LLVM module names for function_name.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.function_unique_gen_name_regex","page":"Home","title":"CodeDiffs.function_unique_gen_name_regex","text":"function_unique_gen_name_regex()\nfunction_unique_gen_name_regex(function_name)\n\nRegex matching all LLVM function names which might change from one compilation to another. As an example, in the outputs of @code_llvm below:\n\njulia> f() = 1\nf (generic function with 1 method)\n\njulia> @code_llvm f()\n...\ndefine i64 @julia_f_855() #0 {\n...\n\njulia> @code_llvm f()\n...\ndefine i64 @julia_f_857() #0 {\n...\n\nthe regex will match julia_f_855 and julia_f_857.\n\nfunction_unique_gen_name_regex() should work for any function which does not have any characters in '\",;- or spaces in its name. The function name is either in the capture group 1 or 2.\n\nfunction_unique_gen_name_regex(function_name) should work with any generated name for the given function name.\n\nIt is 'globalUniqueGeneratedNames' in 'julia/src/codegen.cpp' which gives the unique number on the generated code. The regex matches most usages of this counter:\n\nfrom get_function_name\njulia_<function_name>_<unique_num>\njapi3_<function_name>_<unique_num>\njapi1_<function_name>_<unique_num>\nfrom 'src/codegen.cpp#L4713'\nj_<function_name>_<unique_num>\nj1_<function_name>_<unique_num>\nfrom 'src/codegen.cpp#L6407'\njlcapi_<function_name>_<unique_num>\nfrom 'src/codegen.cpp#L7753'\njfptr_<function_name>_<unique_num>\nfrom 'src/codegen.cpp#L6185'\ntojlinvoke<unique_num>\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.global_var_unique_gen_name_regex","page":"Home","title":"CodeDiffs.global_var_unique_gen_name_regex","text":"global_var_unique_gen_name_regex()\nglobal_var_unique_gen_name_regex(global_name)\n\nRegex matching all global variable names which might change from one compilation to another.\n\ncompat: Julia 1.11\nThose global variables names only appear starting from Julia 1.11.\n\nIn LLVM IR, those variables are mentioned as such: @\"+Core.GenericMemory#14067.jit\". In native code, they look like this: \".L+Core.GenericMemory#13985.jit\", with maybe some .set and .size sections at the end of the code (in x86 ASM).\n\nglobal_var_unique_gen_name_regex() should work for any variable which does not have any characters in '\",;- or spaces in its name.\n\nglobal_var_unique_gen_name_regex(global_name) should work with any generated name for the given variable name.\n\nIt is 'globalUniqueGeneratedNames' in 'julia/src/codegen.cpp' which gives the unique number on the generated code. The regex matches only a single usage of this counter: in julia_pgv(ctx, cname, addr) at 'src/cgutils.cpp#L358' which is then added a \".jit\" suffix in 'src/aotcompile.cpp#L2064' when doing code introspection.\n\n\n\n\n\n","category":"function"},{"location":"#Diff-display","page":"Home","title":"Diff display","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"optimize_line_changes!\nside_by_side_diff","category":"page"},{"location":"#CodeDiffs.optimize_line_changes!","page":"Home","title":"CodeDiffs.optimize_line_changes!","text":"optimize_line_changes!(diff::CodeDiff; dist=Levenshtein(), tol=0.7)\n\nMerges consecutive line removals+additions into single line changes in diff, when they are within the tolerance of the normalized string distance.\n\nThis does not aim to produce an optimal CodeDiff, but simply improve its display.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.side_by_side_diff","page":"Home","title":"CodeDiffs.side_by_side_diff","text":"side_by_side_diff([io::IO,] diff::CodeDiff; tab_width=4, width=nothing, line_numbers=nothing)\n\nSide by side display of a CodeDiff to io (defaults to stdout).\n\nwidth defaults to the width of the terminal. It is 80 by default for non-terminal io.\n\ntab_width is the number of spaces tabs are replaced with.\n\nline_numbers=true will add line numbers on each side of the columns. It defaults to the environment variable \"CODE_DIFFS_LINE_NUMBERS\", which itself defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"CurrentModule = CodeDiffs","category":"page"},{"location":"extensions/#KernelAbstractions.jl","page":"Extensions","title":"KernelAbstractions.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"@code_diff will automatically detect calls to KernelAbstractions.jl and get the code for the actual underlying kernel function (whatever the backend is). To do this, the kernel call must be complete: both workgroupsize and ndrange must have a value, either from when instantiating the kernel for a backend (gpu_kernel = my_kernel(CUDABackend(), 1024)) or when calling the kernel (gpu_kernel(a, b, c; ndrange=1000)).","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"There is no support for AST comparison with KA.jl kernels.","category":"page"},{"location":"extensions/#GPU-kernels","page":"Extensions","title":"GPU kernels","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"@code_diff supports functions compiled in a GPU context with any of the GPU packages:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"CUDA.jl\nAMDGPU.jl \noneAPI.jl\nMetal.jl","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Each compilation step has its own code type:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":":cuda_typed/:rocm_typed/:one_typed/:mtl_typed typed Julia IR for the GPU (output of @device_code_typed)\n:cuda_llvm/:rocm_llvm/:one_llvm/:mtl_llvm GPU LLVM IR (output of @device_code_llvm)\n:cuda_native/:rocm_native/:one_native/:mtl_native native GPU assembly (output of @device_code_native). Each have an alias using the assembly name: :ptx/:gcn/:spirv/:agx.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"CUDA has one additional layer of assembly code, SASS, available with :sass.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"info: Info\nUnlike with the @device_code_* macros, no kernel code is executed by @code_diff. This also means that kernels launched indirectly by the function will be ignored.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"info: Info\nNote that behind the scenes, GPUCompiler.jl only cares about the most recent methods. Hence the world keyword is unsupported for all GPU backends, as we cannot compile back in time.","category":"page"},{"location":"extensions/#Defining-a-new-extension","page":"Extensions","title":"Defining a new extension","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Defining a new code_type involves four functions:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"CodeDiffs.get_code_dispatch(::Val{code_type}, f, types; kwargs...) (not get_code!) should return a printable object (usually a String) representing the code for f(types). kwargs are the options passed to @code_diff.\nCodeDiffs.cleanup_code(::Val{:code_type}, obj) does some cleanup on the code object to make it more diff-able\nCodeDiffs.code_highlighter(::Val{code_type}) returns a f(io, obj) to print the obj to as text in io. This is done twice: once without highlighting (get(io, :color, false) == false), and another with highlighting.\nCodeDiffs.argconvert(::Val{code_type}, arg) converts arg as needed (by default arg is unchanged)","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Defining a new pre-processing step for functions and its arguments (like for KernelAbstractions.jl kernels) involves two functions:","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"CodeDiffs.extract_extra_options(f, kwargs) returns some additional kwargs which are passed to get_code\nCodeDiffs.get_code(code_type, f, types; kwargs...) allows to change f depending on its type. To avoid method ambiguities, do not put type constraints on code_type.","category":"page"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Defining a new object type which can be put as an argument to @code_diff or @code_for invoves at one function: CodeDiffs.code_for_diff(obj::YourType; kwargs...). It must return two Strings, one without and the other without highlighting. When calling @code_for obj, code_for_diff(obj) will be called only if obj is not a call expression or a quoted Expr. kwargs are the options passed to @code_for or the options passed to @code_diff for the side of obj.","category":"page"}]
}
