var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CodeDiffs","category":"page"},{"location":"#CodeDiffs","page":"Home","title":"CodeDiffs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compare different types of code and display it in the terminal. For cleaner results, syntax highlighting is separated from the difference calculation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supports:","category":"page"},{"location":"","page":"Home","title":"Home","text":"native CPU assembly (output of @code_native, highlighted by InteractiveUtils.print_native)\nLLVM IR (output of @code_llvm, highlighted by InteractiveUtils.print_llvm)\nTyped Julia IR (output of @code_typed, highlighted through the Base.show method of Core.CodeInfo)\nJulia AST (an Expr), highlighting is done with OhMyREPL.jl's Julia syntax highlighting in Markdown code blocks","category":"page"},{"location":"","page":"Home","title":"Home","text":"The @code_diff macro is the main entry point. If possible, the code type will be detected automatically, otherwise add e.g. type=:llvm for LLVM IR comparison:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f1(a) = a + 1\nf1 (generic function with 1 method)\n\njulia> @code_diff type=:llvm debuginfo=:none color=false f1(Int64(1)) f1(Int8(1))\ndefine i64 @f1(i64 signext %0) #0 {   ⟪╋⟫define i64 @f1(i8 signext %0) #0 {\ntop:                                   ┃ top:\n                                       ┣⟫  %1 = sext i8 %0 to i64\n  %1 = add i64 %0, 1                  ⟪╋⟫  %2 = add nsw i64 %1, 1\n  ret i64 %1                          ⟪╋⟫  ret i64 %2\n}                                      ┃ }\n\njulia> f2(a) = a - 1\nf2 (generic function with 1 method)\n\njulia> @code_diff type=:llvm debuginfo=:none color=false f1(1) f2(1)\ndefine i64 @f1(i64 signext %0) #0 {   ⟪╋⟫define i64 @f2(i64 signext %0) #0 {\ntop:                                   ┃ top:\n  %1 = add i64 %0, 1                  ⟪╋⟫  %1 = add i64 %0, -1\n  ret i64 %1                           ┃   ret i64 %1\n}                                      ┃ }","category":"page"},{"location":"","page":"Home","title":"Home","text":"Setting the environment variable \"CODE_DIFFS_LINE_NUMBERS\" to true will display line numbers on each side:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ENV[\"CODE_DIFFS_LINE_NUMBERS\"] = true\ntrue\n\njulia> @code_diff type=:llvm debuginfo=:none color=false f1(1) f2(1)\n1 define i64 @f1(i64 signext %0) #0 { ⟪╋⟫define i64 @f2(i64 signext %0) #0 { 1\n2 top:                                 ┃ top:                                2\n3   %1 = add i64 %0, 1                ⟪╋⟫  %1 = add i64 %0, -1               3\n4   ret i64 %1                         ┃   ret i64 %1                        4\n5 }                                    ┃ }                                   5","category":"page"},{"location":"#Comparison-entry-points","page":"Home","title":"Comparison entry points","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@code_diff\ncode_diff\ncode_for_diff\nCodeDiff","category":"page"},{"location":"#CodeDiffs.@code_diff","page":"Home","title":"CodeDiffs.@code_diff","text":"@code_diff [type=:native] [color=true] [option=value...] f₁(...) f₂(...)\n@code_diff [option=value...] :(expr₁) :(expr₂)\n\nCompare the methods called by the f₁(...) and f₂(...) or the expressions expr₁ and expr₂, then return a CodeDiff.\n\noptions are passed to get_code. Option names ending with _1 or _2 are passed to the call of get_code for f₁ and f₂ respectively. They can also be packed into extra_1 and extra_2.\n\nTo compare Expr in variables, use @code_diff :($a) :($b).\n\n# Default comparison\n@code_diff type=:native f() g()\n\n# No debuginfo for `f()` and `g()`\n@code_diff type=:native debuginfo=:none f() g()\n\n# No debuginfo for `f()`\n@code_diff type=:native debuginfo_1=:none f() g()\n\n# No debuginfo for `g()`\n@code_diff type=:native debuginfo_2=:none f() g()\n\n# Options can be passed from variables with `extra_1` and `extra_2`\nopts = (; debuginfo=:none, world=Base.get_world_counter())\n@code_diff type=:native extra_1=opts extra_2=opts f() g()\n\n# `type` and `color` can also be made different in each side\n@code_diff type_1=:native type_2=:llvm f() f()\n\n\n\n\n\n","category":"macro"},{"location":"#CodeDiffs.code_diff","page":"Home","title":"CodeDiffs.code_diff","text":"code_diff(args₁::Tuple, args₂::Tuple; extra_1=(;), extra_2=(;), kwargs...)\n\nFunction equivalent to @code_diff(extra_1, extra_2, kwargs..., args₁, args₂). kwargs are common to both sides, while extra_1 and extra_2 are passed to code_for_diff only with args₁ and args₂ respectively.\n\njulia> diff_1 = @code_diff debuginfo_1=:none f() g();\n\njulia> diff_2 = code_diff((f, Tuple{}), (g, Tuple{}); extra_1=(; debuginfo=:none));\n\njulia> diff_1 == diff_2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.code_for_diff","page":"Home","title":"CodeDiffs.code_for_diff","text":"code_for_diff(f::Base.Callable, types::Type{<:Tuple}; type=:native, color=true, kwargs...)\ncode_for_diff(expr::Expr; type=:ast, color=true, kwargs...)\n\nFetches the code of f with get_code(Val(type), f, types; kwargs...), cleans it up with cleanup_code(Val(type), code) and highlights it using the appropriate code_highlighter(Val(type)). The result is two Strings: one without and the other with highlighting.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.CodeDiff","page":"Home","title":"CodeDiffs.CodeDiff","text":"CodeDiff(code₁, code₂)\nCodeDiff(code₁, code₂, highlighted₁, highlighted₂)\n\nA difference between code₁ and code₂.\n\ncode₁ and code₂ should have no highlighting. Only highlighted₁ and highlighted₂ should have syntax highlighting. When showing the differences, their formatting will be re-applied.\n\nFor cleaner differences, use replace_llvm_module_name on all codes.\n\nUse optimize_line_changes! to improve the difference.\n\nFancy REPL output is done with side_by_side_diff.\n\n\n\n\n\n","category":"type"},{"location":"#Code-fetching","page":"Home","title":"Code fetching","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"code_native\ncode_llvm\ncode_typed\ncode_ast\nget_code","category":"page"},{"location":"#CodeDiffs.code_native","page":"Home","title":"CodeDiffs.code_native","text":"code_native(f, types; world=nothing, kwargs...)\n\nThe native code of the method of f called with types (a Tuple type), as a string. world defaults to the current world age. kwargs are forwarded to InteractiveUtils.code_native.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.code_llvm","page":"Home","title":"CodeDiffs.code_llvm","text":"code_llvm(f, types; world=nothing, kwargs...)\n\nThe LLVM-IR code of the method of f called with types (a Tuple type), as a string. world defaults to the current world age. kwargs are forwarded to InteractiveUtils.code_native.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.code_typed","page":"Home","title":"CodeDiffs.code_typed","text":"code_typed(f, types; world=nothing, kwargs...)\n\nThe Julia-IR code (aka 'typed code') of the method of f called with types (a Tuple type), as a Core.CodeInfo. world defaults to the current world age. kwargs are forwarded to Base.code_typed.\n\nThe function call should only match a single method.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.code_ast","page":"Home","title":"CodeDiffs.code_ast","text":"code_ast(f, types; world=nothing, prettify=true, lines=false, alias=false)\n\nThe Julia AST of the method of f called with types (a Tuple type), as a Expr. Revise.jl is used to get those definitions, and it must be loaded before the definition of f's method to get the AST for.\n\nworld defaults to the current world age. Since Revise.jl does not keep track of all definitions in all world ages, it is very likely that the only retrievable definition is the most recent one.\n\nIf prettify == true, then MacroTools.prettify(code; lines, alias) is used to cleanup the AST. lines == true will keep the LineNumberNodes and alias == true will replace mangled names (or gensyms) by more readable names.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.get_code","page":"Home","title":"CodeDiffs.get_code","text":"get_code(::Val{code_type}, f, types; world=nothing, kwargs...)\n\nThe code object of code_type for f. Dispatch depends on code_type:\n\n:native: code_native\n:llvm: code_llvm\n:typed: code_typed\n:ast: code_ast\n\n\n\n\n\n","category":"function"},{"location":"#Highlighting","page":"Home","title":"Highlighting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"code_highlighter","category":"page"},{"location":"#CodeDiffs.code_highlighter","page":"Home","title":"CodeDiffs.code_highlighter","text":"code_highlighter(::Val{code_type}) where {code_type}\n\nReturn a function of signature (io::IO, code_obj) which prints code_obj to io with highlighting/decorations. By default print(io, code_obj) is used for AbstractStrings and Base.show(io, MIME\"text/plain\"(), code_obj) otherwise.\n\nThe highlighting function is called twice: once for color-less text and again with color.\n\n\n\n\n\n","category":"function"},{"location":"#Cleanup","page":"Home","title":"Cleanup","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"cleanup_code\nreplace_llvm_module_name\nLLVM_MODULE_NAME_REGEX","category":"page"},{"location":"#CodeDiffs.cleanup_code","page":"Home","title":"CodeDiffs.cleanup_code","text":"cleanup_code(::Val{code_type}, code)\n\nPerform minor changes to code to improve readability and the quality of the differences.\n\nCurrently only replace_llvm_module_name is applied to :native and :llvm code.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.replace_llvm_module_name","page":"Home","title":"CodeDiffs.replace_llvm_module_name","text":"replace_llvm_module_name(code::AbstractString)\n\nRemove in code the trailing numbers in the LLVM module names, e.g. \"julia_f_2007\" => \"f\". This allows to remove false differences when comparing raw code, since each call to code_native (or code_llvm) triggers a new compilation using an unique LLVM module name, therefore each consecutive call is different even though the actual code does not change.\n\njulia> f() = 1\nf (generic function with 1 method)\n\njulia> buf = IOBuffer();\n\njulia> code_native(buf, f, Tuple{})  # Equivalent to `@code_native f()`\n\njulia> code₁ = String(take!(buf));\n\njulia> code_native(buf, f, Tuple{})\n\njulia> code₂ = String(take!(buf));\n\njulia> code₁ == code₂  # Different LLVM module names...\nfalse\n\njulia> replace_llvm_module_name(code₁) == replace_llvm_module_name(code₂)  # ...but same code\ntrue\n\n\n\n\n\nreplace_llvm_module_name(code::AbstractString, function_name)\n\nReplace only LLVM module names for function_name.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.LLVM_MODULE_NAME_REGEX","page":"Home","title":"CodeDiffs.LLVM_MODULE_NAME_REGEX","text":"LLVM_MODULE_NAME_REGEX\n\nShould match the LLVM module of any function which does not have any of '\",;- or spaces in it.\n\nIt is 'get_function_name', in 'julia/src/codegen.cpp' which builds the function name for the LLVM module used to get the function code. The regex is built to match any output from that function. Since the 'globalUniqueGeneratedNames' counter (the number at the end of the module name) is incremented at each call to 'get_function_name', and since code_llvm or code_native forces a compilation, it should be guaranteed that the match with the highest number at the end is the name of our function in code.\n\n\n\n\n\n","category":"constant"},{"location":"#Diff-display","page":"Home","title":"Diff display","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"optimize_line_changes!\nside_by_side_diff","category":"page"},{"location":"#CodeDiffs.optimize_line_changes!","page":"Home","title":"CodeDiffs.optimize_line_changes!","text":"optimize_line_changes!(diff::CodeDiff; dist=Levenshtein(), tol=0.7)\n\nMerges consecutive line removals+additions into single line changes in diff, when they are within the tolerance of the normalized string distance.\n\nThis does not aim to produce an optimal CodeDiff, but simply improve its display.\n\n\n\n\n\n","category":"function"},{"location":"#CodeDiffs.side_by_side_diff","page":"Home","title":"CodeDiffs.side_by_side_diff","text":"side_by_side_diff([io::IO,] diff::CodeDiff; tab_width=4, width=nothing, line_numbers=nothing)\n\nSide by side display of a CodeDiff to io (defaults to stdout).\n\nwidth defaults to the width of the terminal. It is 80 by default for non-terminal io.\n\ntab_width is the number of spaces tabs are replaced with.\n\nline_numbers=true will add line numbers on each side of the columns. It defaults to the environment variable \"CODE_DIFFS_LINE_NUMBERS\", which itself defaults to false.\n\n\n\n\n\n","category":"function"}]
}
